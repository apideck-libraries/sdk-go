// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"github.com/apideck-libraries/sdk-go/internal/utils"
	"github.com/apideck-libraries/sdk-go/models/components"
	"io"
)

type ProxyPostProxyGlobals struct {
	// ID of the consumer which you want to get or push data from
	ConsumerID *string `header:"style=simple,explode=false,name=x-apideck-consumer-id"`
	// The ID of your Unify application
	AppID *string `header:"style=simple,explode=false,name=x-apideck-app-id"`
}

func (p *ProxyPostProxyGlobals) GetConsumerID() *string {
	if p == nil {
		return nil
	}
	return p.ConsumerID
}

func (p *ProxyPostProxyGlobals) GetAppID() *string {
	if p == nil {
		return nil
	}
	return p.AppID
}

type Three struct {
}

func (t Three) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *Three) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

type One struct {
}

func (o One) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *One) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

type ProxyPostProxyRequest struct {
	// ID of the consumer which you want to get or push data from
	ConsumerID *string `header:"style=simple,explode=false,name=x-apideck-consumer-id"`
	// The ID of your Unify application
	AppID *string `header:"style=simple,explode=false,name=x-apideck-app-id"`
	// Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API.
	ServiceID string `header:"style=simple,explode=false,name=x-apideck-service-id"`
	// Specify which unified API to use for the connection lookup. Required for multi-API connectors (e.g., Workday) to ensure the correct credentials are used.
	UnifiedAPI *string `header:"style=simple,explode=false,name=x-apideck-unified-api"`
	// Downstream URL
	DownstreamURL string `header:"style=simple,explode=false,name=x-apideck-downstream-url"`
	// Downstream authorization header. This will skip the Vault token injection.
	DownstreamAuthorization *string `header:"style=simple,explode=false,name=x-apideck-downstream-authorization"`
	// Depending on the verb/method of the request this will contain the request body you want to POST/PATCH/PUT.
	// This field accepts []byte data or io.Reader implementations, such as *os.File.
	RequestBody *any `request:"mediaType=*/*"`
}

func (p *ProxyPostProxyRequest) GetConsumerID() *string {
	if p == nil {
		return nil
	}
	return p.ConsumerID
}

func (p *ProxyPostProxyRequest) GetAppID() *string {
	if p == nil {
		return nil
	}
	return p.AppID
}

func (p *ProxyPostProxyRequest) GetServiceID() string {
	if p == nil {
		return ""
	}
	return p.ServiceID
}

func (p *ProxyPostProxyRequest) GetUnifiedAPI() *string {
	if p == nil {
		return nil
	}
	return p.UnifiedAPI
}

func (p *ProxyPostProxyRequest) GetDownstreamURL() string {
	if p == nil {
		return ""
	}
	return p.DownstreamURL
}

func (p *ProxyPostProxyRequest) GetDownstreamAuthorization() *string {
	if p == nil {
		return nil
	}
	return p.DownstreamAuthorization
}

func (p *ProxyPostProxyRequest) GetRequestBody() *any {
	if p == nil {
		return nil
	}
	return p.RequestBody
}

type ProxyPostProxyResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// Ok
	ResponseJSON map[string]any
	// Ok
	// The Close method must be called on this field, even if it is not used, to prevent resource leaks.
	ResponseBinary io.ReadCloser
	// Ok
	// The Close method must be called on this field, even if it is not used, to prevent resource leaks.
	ResponsePdf io.ReadCloser
	// Ok
	ResponseXML *string
	// Ok
	ResponseCsv *string
	// Ok
	ResponseText *string
	// Proxy error
	ErrorJSON map[string]any
	// Proxy error
	ErrorXML *string
	// Proxy error
	ErrorHTML *string
	// Proxy error
	ErrorText *string
	Headers   map[string][]string
}

func (p *ProxyPostProxyResponse) GetHTTPMeta() components.HTTPMetadata {
	if p == nil {
		return components.HTTPMetadata{}
	}
	return p.HTTPMeta
}

func (p *ProxyPostProxyResponse) GetResponseJSON() map[string]any {
	if p == nil {
		return nil
	}
	return p.ResponseJSON
}

func (p *ProxyPostProxyResponse) GetResponseBinary() io.ReadCloser {
	if p == nil {
		return nil
	}
	return p.ResponseBinary
}

func (p *ProxyPostProxyResponse) GetResponsePdf() io.ReadCloser {
	if p == nil {
		return nil
	}
	return p.ResponsePdf
}

func (p *ProxyPostProxyResponse) GetResponseXML() *string {
	if p == nil {
		return nil
	}
	return p.ResponseXML
}

func (p *ProxyPostProxyResponse) GetResponseCsv() *string {
	if p == nil {
		return nil
	}
	return p.ResponseCsv
}

func (p *ProxyPostProxyResponse) GetResponseText() *string {
	if p == nil {
		return nil
	}
	return p.ResponseText
}

func (p *ProxyPostProxyResponse) GetErrorJSON() map[string]any {
	if p == nil {
		return nil
	}
	return p.ErrorJSON
}

func (p *ProxyPostProxyResponse) GetErrorXML() *string {
	if p == nil {
		return nil
	}
	return p.ErrorXML
}

func (p *ProxyPostProxyResponse) GetErrorHTML() *string {
	if p == nil {
		return nil
	}
	return p.ErrorHTML
}

func (p *ProxyPostProxyResponse) GetErrorText() *string {
	if p == nil {
		return nil
	}
	return p.ErrorText
}

func (p *ProxyPostProxyResponse) GetHeaders() map[string][]string {
	if p == nil {
		return map[string][]string{}
	}
	return p.Headers
}
