// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/apideck-libraries/sdk-go/internal/utils"
	"time"
)

// MessageType - Set to sms for SMS messages and mms for MMS messages.
type MessageType string

const (
	MessageTypeSms MessageType = "sms"
	MessageTypeMms MessageType = "mms"
)

func (e MessageType) ToPointer() *MessageType {
	return &e
}
func (e *MessageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sms":
		fallthrough
	case "mms":
		*e = MessageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageType: %v", v)
	}
}

// Direction - The direction of the message.
type Direction string

const (
	DirectionInbound       Direction = "inbound"
	DirectionOutboundAPI   Direction = "outbound-api"
	DirectionOutboundCall  Direction = "outbound-call"
	DirectionOutboundReply Direction = "outbound-reply"
	DirectionUnknown       Direction = "unknown"
)

func (e Direction) ToPointer() *Direction {
	return &e
}
func (e *Direction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "inbound":
		fallthrough
	case "outbound-api":
		fallthrough
	case "outbound-call":
		fallthrough
	case "outbound-reply":
		fallthrough
	case "unknown":
		*e = Direction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Direction: %v", v)
	}
}

// MessageStatus - Status of the delivery of the message.
type MessageStatus string

const (
	MessageStatusAccepted    MessageStatus = "accepted"
	MessageStatusScheduled   MessageStatus = "scheduled"
	MessageStatusCanceled    MessageStatus = "canceled"
	MessageStatusQueued      MessageStatus = "queued"
	MessageStatusSending     MessageStatus = "sending"
	MessageStatusSent        MessageStatus = "sent"
	MessageStatusFailed      MessageStatus = "failed"
	MessageStatusDelivered   MessageStatus = "delivered"
	MessageStatusUndelivered MessageStatus = "undelivered"
	MessageStatusReceiving   MessageStatus = "receiving"
	MessageStatusReceived    MessageStatus = "received"
	MessageStatusRead        MessageStatus = "read"
)

func (e MessageStatus) ToPointer() *MessageStatus {
	return &e
}
func (e *MessageStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "accepted":
		fallthrough
	case "scheduled":
		fallthrough
	case "canceled":
		fallthrough
	case "queued":
		fallthrough
	case "sending":
		fallthrough
	case "sent":
		fallthrough
	case "failed":
		fallthrough
	case "delivered":
		fallthrough
	case "undelivered":
		fallthrough
	case "receiving":
		fallthrough
	case "received":
		fallthrough
	case "read":
		*e = MessageStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageStatus: %v", v)
	}
}

// Price of the message.
type Price struct {
	PerUnit     *string `json:"per_unit,omitempty"`
	TotalAmount *string `json:"total_amount,omitempty"`
	// Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
	Currency *Currency `json:"currency,omitempty"`
}

func (p *Price) GetPerUnit() *string {
	if p == nil {
		return nil
	}
	return p.PerUnit
}

func (p *Price) GetTotalAmount() *string {
	if p == nil {
		return nil
	}
	return p.TotalAmount
}

func (p *Price) GetCurrency() *Currency {
	if p == nil {
		return nil
	}
	return p.Currency
}

// Error - The error returned if your message status is failed or undelivered.
type Error struct {
	// The error_code provides more information about the failure. If the message was successful, this value is null
	Code    *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

func (e *Error) GetCode() *string {
	if e == nil {
		return nil
	}
	return e.Code
}

func (e *Error) GetMessage() *string {
	if e == nil {
		return nil
	}
	return e.Message
}

type Message struct {
	// A unique identifier for an object.
	ID *string `json:"id,omitempty"`
	// The phone number that initiated the message.
	From string `json:"from"`
	// The phone number that received the message.
	To      string  `json:"to"`
	Subject *string `json:"subject,omitempty"`
	// The message text.
	Body string `json:"body"`
	// Set to sms for SMS messages and mms for MMS messages.
	Type *MessageType `json:"type,omitempty"`
	// The number of units that make up the complete message. Messages can be split up due to the constraints of the message size.
	NumberOfUnits *int64 `json:"number_of_units,omitempty"`
	// The number of media files associated with the message.
	NumberOfMediaFiles *int64 `json:"number_of_media_files,omitempty"`
	// The direction of the message.
	Direction *Direction `json:"direction,omitempty"`
	// Status of the delivery of the message.
	Status *MessageStatus `json:"status,omitempty"`
	// The scheduled date and time of the message.
	ScheduledAt *time.Time `json:"scheduled_at,omitempty"`
	// The date and time that the message was sent
	SentAt *time.Time `json:"sent_at,omitempty"`
	// Define a webhook to receive delivery notifications.
	WebhookURL *string `json:"webhook_url,omitempty"`
	// A client reference.
	Reference *string `json:"reference,omitempty"`
	// Price of the message.
	Price *Price `json:"price,omitempty"`
	// The error returned if your message status is failed or undelivered.
	Error *Error `json:"error,omitempty"`
	// The ID of the Messaging Service used with the message. In case of Plivo this links to the Powerpack ID.
	MessagingServiceID *string `json:"messaging_service_id,omitempty"`
	// When custom mappings are configured on the resource, the result is included here.
	CustomMappings map[string]any `json:"custom_mappings,omitempty"`
	// The user who last updated the object.
	UpdatedBy *string `json:"updated_by,omitempty"`
	// The user who created the object.
	CreatedBy *string `json:"created_by,omitempty"`
	// The date and time when the object was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	// The date and time when the object was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
	PassThrough []PassThroughBody `json:"pass_through,omitempty"`
}

func (m Message) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *Message) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (m *Message) GetID() *string {
	if m == nil {
		return nil
	}
	return m.ID
}

func (m *Message) GetFrom() string {
	if m == nil {
		return ""
	}
	return m.From
}

func (m *Message) GetTo() string {
	if m == nil {
		return ""
	}
	return m.To
}

func (m *Message) GetSubject() *string {
	if m == nil {
		return nil
	}
	return m.Subject
}

func (m *Message) GetBody() string {
	if m == nil {
		return ""
	}
	return m.Body
}

func (m *Message) GetType() *MessageType {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *Message) GetNumberOfUnits() *int64 {
	if m == nil {
		return nil
	}
	return m.NumberOfUnits
}

func (m *Message) GetNumberOfMediaFiles() *int64 {
	if m == nil {
		return nil
	}
	return m.NumberOfMediaFiles
}

func (m *Message) GetDirection() *Direction {
	if m == nil {
		return nil
	}
	return m.Direction
}

func (m *Message) GetStatus() *MessageStatus {
	if m == nil {
		return nil
	}
	return m.Status
}

func (m *Message) GetScheduledAt() *time.Time {
	if m == nil {
		return nil
	}
	return m.ScheduledAt
}

func (m *Message) GetSentAt() *time.Time {
	if m == nil {
		return nil
	}
	return m.SentAt
}

func (m *Message) GetWebhookURL() *string {
	if m == nil {
		return nil
	}
	return m.WebhookURL
}

func (m *Message) GetReference() *string {
	if m == nil {
		return nil
	}
	return m.Reference
}

func (m *Message) GetPrice() *Price {
	if m == nil {
		return nil
	}
	return m.Price
}

func (m *Message) GetError() *Error {
	if m == nil {
		return nil
	}
	return m.Error
}

func (m *Message) GetMessagingServiceID() *string {
	if m == nil {
		return nil
	}
	return m.MessagingServiceID
}

func (m *Message) GetCustomMappings() map[string]any {
	if m == nil {
		return nil
	}
	return m.CustomMappings
}

func (m *Message) GetUpdatedBy() *string {
	if m == nil {
		return nil
	}
	return m.UpdatedBy
}

func (m *Message) GetCreatedBy() *string {
	if m == nil {
		return nil
	}
	return m.CreatedBy
}

func (m *Message) GetUpdatedAt() *time.Time {
	if m == nil {
		return nil
	}
	return m.UpdatedAt
}

func (m *Message) GetCreatedAt() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *Message) GetPassThrough() []PassThroughBody {
	if m == nil {
		return nil
	}
	return m.PassThrough
}

type MessageInput struct {
	// The phone number that initiated the message.
	From string `json:"from"`
	// The phone number that received the message.
	To      string  `json:"to"`
	Subject *string `json:"subject,omitempty"`
	// The message text.
	Body string `json:"body"`
	// Set to sms for SMS messages and mms for MMS messages.
	Type *MessageType `json:"type,omitempty"`
	// The scheduled date and time of the message.
	ScheduledAt *time.Time `json:"scheduled_at,omitempty"`
	// Define a webhook to receive delivery notifications.
	WebhookURL *string `json:"webhook_url,omitempty"`
	// A client reference.
	Reference *string `json:"reference,omitempty"`
	// The ID of the Messaging Service used with the message. In case of Plivo this links to the Powerpack ID.
	MessagingServiceID *string `json:"messaging_service_id,omitempty"`
	// The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
	PassThrough []PassThroughBody `json:"pass_through,omitempty"`
}

func (m MessageInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MessageInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (m *MessageInput) GetFrom() string {
	if m == nil {
		return ""
	}
	return m.From
}

func (m *MessageInput) GetTo() string {
	if m == nil {
		return ""
	}
	return m.To
}

func (m *MessageInput) GetSubject() *string {
	if m == nil {
		return nil
	}
	return m.Subject
}

func (m *MessageInput) GetBody() string {
	if m == nil {
		return ""
	}
	return m.Body
}

func (m *MessageInput) GetType() *MessageType {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MessageInput) GetScheduledAt() *time.Time {
	if m == nil {
		return nil
	}
	return m.ScheduledAt
}

func (m *MessageInput) GetWebhookURL() *string {
	if m == nil {
		return nil
	}
	return m.WebhookURL
}

func (m *MessageInput) GetReference() *string {
	if m == nil {
		return nil
	}
	return m.Reference
}

func (m *MessageInput) GetMessagingServiceID() *string {
	if m == nil {
		return nil
	}
	return m.MessagingServiceID
}

func (m *MessageInput) GetPassThrough() []PassThroughBody {
	if m == nil {
		return nil
	}
	return m.PassThrough
}
